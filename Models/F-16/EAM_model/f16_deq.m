function xd = f16_deq(u,x,c)%%  function xd = f16_deq(u,x,c)%%  Usage: xd = f16_deq(u,x,c);%%%  Description:%%    Computes the state derivatives for the %    F-16 nonlinear equations of motion, %    based on NASA TP-1538, December 1979.%%  Input:%    %    u = input vector = [ thtl  (0 <= thtl <= 1.0)%                          el   (deg)%                          ail  (deg)%                          rdr  (deg) ];%%    x = state vector = [   vt  (ft/sec)%                         alpha (rad)%                          beta (rad)%                           phi (rad)%                           the (rad)%                           psi (rad)%                            p  (rad/sec)%                            q  (rad/sec)%                            r  (rad/sec)%                           xe  (ft)%                           ye  (ft)%                            h  (ft)  %                           pow (percent, 0 <= pow <= 100) ];%%    c = vector of constants:  c(1) through c(9) = inertia constants.%                              c(10) = aircraft mass, slugs.%                              c(11) = xcg, longitudinal c.g. location,%                                      distance normalized by the m.a.c.%%  Output:%%    xd = state vector time derivative.%%%    Calls:%      atm.m%      f16_engine.m%      f16_aero.m%      tgear.m%      pdot.m%      %    Author:  Eugene A. Morelli%%    History:  %     18 May  1995 - Created and debugged, EAM.%     17 July 2001 - Added independent variable limits, EAM.%%%  Copyright (C) 2000  Eugene A. Morelli%%%  This program carries no warranty, not even the implied %  warranty of merchantability or fitness for a particular purpose.  %%  Please email bug reports or suggestions for improvements to:%%      e.a.morelli@larc.nasa.gov%global CXO CZO CMO CLO CNO DDERglobal DLDA DLDR DNDA DNDRglobal IDP MLP MXPxd=zeros(length(x),1);sarea=300.;bspan=30.;cbar=11.32;xcg=c(11);heng=160.0;rtd=180./pi;g=32.174;%%  Assign state and control variables.%vt=x(1);alpha=x(2)*rtd;beta=x(3)*rtd;phi=x(4);the=x(5);psi=x(6);p=x(7);q=x(8);r=x(9);alt=x(12);pow=x(13);thtl=u(1);el=u(2);ail=u(3);rdr=u(4);%%  Limits for table look-ups.  Add some space for %  extrapolation in alpha and beta.  %%alpha=max([-10,min([alpha,45])]);%beta=max([-30,min([beta,30])]);alpha=max([-45,min([alpha,80])]);beta=max([-45,min([beta,45])]);alt=max([0,min([alt,50000])]);pow=max([0,min([pow,100])]);thtl=max([0,min([thtl,1])]);el=max([-25,min([el,25])]);ail=max([-20,min([ail,20])]);rdr=max([-30,min([rdr,30])]);%%  Compute air data.%[mach,qbar]=atm(vt,alt);%%  Compute engine thrust.%thrust=f16_engine(pow,alt,mach);%%  Compute aerodynamic force and moment coefficients.%[cx,cy,cz,cl,cm,cn]=f16_aero(vt,alpha,beta,p,q,r,el,ail,rdr,xcg);%%  Compute quantities used often in the state equations. %cb=cos(x(3));us=vt*cos(x(2))*cb;vs=vt*sin(x(3));ws=vt*sin(x(2))*cb;sth=sin(the);cth=cos(the);sph=sin(phi);cph=cos(phi);sps=sin(psi);cps=cos(psi);qs=qbar*sarea;qsb=qs*bspan;%%  Force equations.%udot=r*vs-q*ws-g*sth+(qs*cx + thrust)/c(10);vdot=p*ws-r*us+g*cth*sph + qs*cy/c(10);wdot=q*us-p*vs+g*cth*cph + qs*cz/c(10);xd(1)=(us*udot+vs*vdot+ws*wdot)/vt;xd(2)=(wdot*us-ws*udot)/(us*us+ws*ws);xd(3)=(vt*vdot-vs*xd(1))/(cb*vt*vt);%%  Kinematic equations.%xd(6)=(q*sph+r*cph)/cth;xd(4)=p + sth*xd(6);xd(5)=q*cph-r*sph;%%  Moment equations.%xd(7)=(c(2)*p+c(1)*r+c(4)*heng)*q + qsb*(c(3)*cl+c(4)*cn);xd(8)=(c(5)*p-c(7)*heng)*r + c(6)*(r*r-p*p) + qs*cbar*c(7)*cm;xd(9)=(c(8)*p-c(2)*r+c(9)*heng)*q + qsb*(c(4)*cl + c(9)*cn);%%  Navigation equations.%bte=[cth*cps,sph*cps*sth-cph*sps,cph*sth*cps+sph*sps;...     cth*sps,sph*sps*sth+cph*cps,cph*sth*sps-sph*cps;...     sth,-sph*cth,-cph*cth];xd(10:12)=bte*[us,vs,ws]';%%  Power level equation.%cpow=tgear(thtl);xd(13)=pdot(pow,cpow);return