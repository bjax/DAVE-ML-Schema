//
// SLDiagram.java
//
//	Helps generate Simulink diagram of DAVE model.
//
//	020619 E. B. Jackson <e.b.jackson@larc.nasa.gov>
//

package gov.nasa.larc.bjax.DAVE.tools.DAVEtoSL;

import java.util.ArrayList;
import java.util.Iterator;
import java.io.PrintStream;
import java.io.IOException;

/**
 *
 * <p> The SLDiagram consists of a rectangular grid of cells, arranged
 * as rows and columns. A simulink block can be contained in a cell,
 * or a cell may be empty. Each cell can contain a single output
 * signal and zero or more input signals. Running below each row and
 * to the left of each column is space for zero or more signal lines
 * connected inputs and outputs.
 *
 **/

public class SLDiagram
{
  Model m;		// our parent model
  ArrayList rows;	// rows of our diagram
  ArrayList cols;	// columns of our diagram
  ArrayList cells;	// individual cells of our diagram

  // Diagram layout parameters
  static int padding  = 25;	// padding between block and cell edge
  static int xMargin  = 10;	// distance from left edge of window
  static int yMargin  = 10;	// distance from top edge of windown


  /**
   *
   * <p> Constructor for SLDiagram </p>
   *
   * <p> When called, the provided <code>Model</code> should contain
   * a completed, wired network with no dangling lines. Ultimately
   * this constructor will figure out placement; for now, we use the
   * one generated by temporary DAVE.createMDL() method. </p>
   *
   * @see gov.nasa.larc.bjax.DAVE.tools.DAVEtoSL.DAVE
   * @param model <code>gov.nasa.larc.bjax.DAVE.Model</code> object to handle
   *
   **/

  public SLDiagram( Model model )
  {

    System.out.println("Building diagram in memory...");
    // save pointer to object
    this.m = model;

    // loop through block list to find dimensions
    int numRows = 1;
    int numCols = 1;
    BlockArrayList blocks = model.getBlocks();
    Iterator iblk = blocks.iterator();

    while (iblk.hasNext())
      {
	Block b = (Block) iblk.next();
	int row = b.getRow();
	int col = b.getCol();
	if(row > numRows) numRows = row;
	if(col > numCols) numCols = col;
      }

    System.out.print(" Found " + numRows + " rows and");
    System.out.println(" " + numCols + " columns.");

    // Create and initialize row & columns for diagram

    this.rows = new ArrayList( numRows+1 );	// create arrays for refs to rows...
    this.cols = new ArrayList( numCols+1 );	//     ...columns..
    this.cells = new ArrayList( numRows * numCols );	// ...and cells.

    for(int i = 0; i < numRows; i++)		// now create rows and...
      this.rows.add(i, new SLRowColumnVector(numCols+1, true));

    for(int i = 0; i < numCols; i++)		// ...columns themselves.
      this.cols.add(i, new SLRowColumnVector(numRows+1, false));

    // loop through and assign blocks to cells, rows, cols

    iblk = blocks.iterator();	// this resets to start of list
    while (iblk.hasNext())
      {
	Block b = (Block) iblk.next();		// get block
	SLCell cell = new SLCell(b, this);	// create cell; saves ref to block and diagram
	this.cells.add( cell );			// add cell to list
	int rowIndex = b.getRow()-1;		// now assign cell to proper...
	int colIndex = b.getCol()-1;		// row and column...
	SLRowColumnVector row = (SLRowColumnVector) this.rows.get( rowIndex );
	SLRowColumnVector col = (SLRowColumnVector) this.cols.get( colIndex );
	row.set(colIndex, cell);		// 'true' tells SLRowColumnVector we're a row
	col.set(rowIndex, cell);		// 'false' indicates column
      }
  }
    
  public int getPadding() { return this.padding; }

  public SLCell getCell( int rowIndex, int colIndex )
  {
    //System.out.println("Looking for cell at [" + rowIndex + "," + colIndex + "]");
    SLRowColumnVector row = (SLRowColumnVector) this.rows.get( rowIndex );
    //    if(row!=null)
    //	System.out.println("  found row index " + rowIndex);
    //    else
    //	System.out.println("  NO ROW FOUND with index " + rowIndex );
    // return row.get(colIndex);
    SLCell theCell = row.get(colIndex);
    //    if(theCell != null)
    //      System.out.println("  found cell at column index " + colIndex );
    //    else
    //      System.out.println("  NO CELL FOUND on row index " + rowIndex +
    //			   " at column index " + colIndex );
    return theCell;
  }


  /**
   *
   * <p> Returns SLCell associated with specified Block </p>
   *
   * @param b <code>Block</code> whose parent SLCell is sought
   *
   **/

  public SLCell getCell( Block b )
  {
    int rowIndex = b.getRow()-1;
    int colIndex = b.getCol()-1;

    return this.getCell( rowIndex, colIndex );
  }


  /**
   *
   * <p> Returns SLRowColumnVector object representing the specified row </p>
   *
   * @param offset 0-based offset or index of desired row
   *
   **/

  public SLRowColumnVector getRow( int index ) { return (SLRowColumnVector) this.rows.get(index); }


  /**
   *
   * <p> Returns SLRowColumnVector object representing the specified column </p>
   *
   * @param offset 0-based offset or index of desired column
   *
   **/

  public SLRowColumnVector getCol( int index ) { return (SLRowColumnVector) this.cols.get(index); }


  /**
   *
   * <p> Create text representation of diagram </p>
   *
   **/

  public void describeSelf( PrintStream printer)
  {
    final int width = 3;

    // print header

    printer.println();
    //    printer.println("Text representation of Simulink diagram:");
    //    printer.println();

    // print column cabletray count
    printer.print("    ");	// margin
    printer.print(" ");		// space
    printer.print("    ");	// margin
    for( int k = 0; k < width; k++) 
      printer.print(" ");
    printer.print("    ");	// margin
    for(int j = 0; j < cols.size(); j++)
      {
	SLRowColumnVector col = (SLRowColumnVector) cols.get(j);
	printer.print(col.cableTray.size());	// need to set size to 2
	printer.print("    ");	// margin
	for( int k = 0; k < width; k++) 
	  printer.print(" ");
	printer.print("    ");	// margin
      }
    for(int i = 0; i < rows.size(); i++)
      {
	SLRowColumnVector row = (SLRowColumnVector) rows.get(i);
	printer.println();
	printer.print("    *");
	for(int j = 0; j < cols.size(); j++)
	  {
	    SLCell cell = (SLCell) row.get(j);
	    if(cell != null)
	      {
		Block b = cell.getBlock();
		printer.print("    ");
		if(b == null)
		  for( int k = 0; k < width; k++)
		    printer.print(" ");
		else
		  {
		    String s = b.getName();
		    if (s.length() < width)
		      {
			printer.print(s);
			for( int k = 0; k < (width-s.length()); k++)
			  printer.print(" ");
		      }
		    else
		      printer.print(s.substring(0,width));
		  }
	      }
	    else	// if cell is null
	      {
		printer.print("    ");
		for( int k = 0; k < width; k++) printer.print(" ");
	      }
	    printer.print("    *");
	  }
	printer.print("\n" + row.cableTray.size());
      }
    printer.println();
    printer.println();
  }


  /**
   *
   * <p> Writes out Simulink MDL description to writer and necessary data statements to mWriter. </p>
   *
   * @param writer SLFileWriter to output model diagrams
   * @param mWriter MatFileWriter to output data
   *
   * @throws java.io.IOException
   *
   **/

  public void createMDL( SLFileWriter writer, MatFileWriter mWriter ) 
    throws IOException
  {
    // update row & column info in blocks

    for( int i = 0; i < rows.size(); i++ )
      {
	SLRowColumnVector row = (SLRowColumnVector) rows.get(i);
	for( int j = 0; j < cols.size(); j++ )
	  {
	    SLCell cell = row.get(j);
	    if( cell != null)
	      {
		Block b = cell.getBlock();
		int oldRow = b.getRow();
		int oldCol = b.getCol();
		if(oldRow != i+1) System.err.println("Updated row number in block " + b.getName() + 
						     " to " + (i+1) + "; was " + oldRow);
		if(oldCol != j+1) System.err.println("Updated col number in block " + b.getName() + 
						     " to " + (j+1) + "; was " + oldCol);
		b.setRowCol( i+1, j+1 );	// convert from offset to index
	      }
	  }
      }

    // write out blocks to MDL file and data to Mat file

    int rowOffset = xMargin;
    Iterator irow = rows.iterator();
    for(int rowIndex = 0; rowIndex < this.rows.size(); rowIndex++)
      {
	// adjust row offset for half row height
	int rowSize = this.getRow( rowIndex ).getSize();	// includes padding around block
	int y = rowOffset + rowSize/2;

	int colOffset = yMargin;
	Iterator icol = cols.iterator();
	for( int colIndex = 0; colIndex < this.cols.size(); colIndex++ )
	  {
	    // adjust column offset for half column width
	    int colSize = this.getCol( colIndex ).getSize();	// includes padding
	    int x = colOffset + colSize/2;

	    SLCell theCell = this.getCell( rowIndex, colIndex );
	    if( theCell != null )
	      {
		Block theBlock = theCell.getBlock();
		if( theBlock != null )
		  {
		    theBlock.createMDL( writer, x, y );
		    theBlock.writeMat( mWriter );
		  }
	      }
	    colOffset = colOffset + colSize;
	  }
	rowOffset = rowOffset + rowSize;
      }

    // write out lines

    // convert generic Signals to SLSignals

    SignalArrayList sigs = m.getSignals();

    Iterator isig = sigs.iterator();
    while (isig.hasNext())
      {
	Signal oldSig = (Signal) isig.next();
	SLSignal newSig = new SLSignal( oldSig, this );	// convert to SLSig
	newSig.initialRoute();				// First pass - create separate path to each dest
	System.out.println("\nInitial route for signal '" + newSig.getName() + "':");
	newSig.describeBranches();

	newSig.makeBranchingRoute();			// Second pass - shared common paths where possible
	System.out.println("\nBranching route for signal '" + newSig.getName() + "':");
	newSig.describePath();

	//	newSig.assignTrays();				// Third pass - assign to cable trays
	//	newSig.describeRoute();
	newSig.createMDL( writer );			// write line to .mdl file
      }
  }
}

